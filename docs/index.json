[{"categories":[],"content":"If you want to report a bug or have a question, create a new issue. Don\u0026rsquo;t forget to label it!\n","date":"Jul 4, 2022","img":"","permalink":"https://0xsuk.github.io/agitcms/bugs-and-questions/","series":[],"tags":[],"title":"Bugs and Questions"},{"categories":[],"content":"Press Ctrl + @ to open/hide.\nPress ctrl+d to kill a process. If a process is killed, integrated terminal automatically closes.\nClick + to add an instance.\nIf you navigate to Home while integrated terminal is open, all instances will be inaccesible, but still be running in the background.\n","date":"Jul 4, 2022","img":"","permalink":"https://0xsuk.github.io/agitcms/integrated-terminal/","series":[],"tags":[],"title":"Integrated Terminal"},{"categories":[],"content":"Media Agit CMS starts local http server on port 3001 to serve media for previewing purpose.\nOn Windows, You have to allow Agit CMS to starts http server when warning is shown.\n![](${media_public_path}/example.png) will be parsed into http://localhost:3001/${media_public_path}/example.png in the right side previewer. (${media_public_path} is a media public path)\nImage placed at the same folder as the markdown post file is in cannot be previewed at this version.\nTo quickly get image path you want to insert into the editor, Agit CMS has a file explorer shortcut button Media for it.\nIt opens media folder path, and selected image\u0026rsquo;s public path will be copied into your clipboard.\nThis way, you can easily type ![](${ctrl + v}) (where ${ctrl + v} means pressing ctrl + v) to insert the image.\nimage pasting Agit CMS supports Ctrl + v to paste image into the editor.\nSet media folder path and media public path to enable this feature.\nmathjax Type\n1$$ 2a + b = c 3$$ to represent block math.\nType\n1$$ a + b = c $$ 2 3or 4 5$ a + b = c $ 6 7or 8 9$ 10a + b = c 11$ to represent inline math.\n","date":"Jul 4, 2022","img":"","permalink":"https://0xsuk.github.io/agitcms/editor/","series":[],"tags":[],"title":"Editor"},{"categories":[],"content":"Agit CMS configration is really simple.\nThere\u0026rsquo;s two configurations.\n Global configuration: applies globally. Site configuration: applies only to specific site.  Let\u0026rsquo;s start with Global configuration\nGlobal configuration Navigate to Home (start page), and click on Settings in GLOBAL section of the sidebar.\nOpen Integrated Terminal with Ctrl+@ Disable this to prevent Agit CMS from opening an integrated terminal when ctrl+@ is captured.\nZoom Change zoom rate.\nSite configuration Go to one of site you added, and click on Settings in SITE section of the sidebar.\nFrontmatter language Define what language you use to represent frontmatter in markdown posts.\nDefault: yaml\nFrontmatter delimiters Define what delimiters you use to wrap frontmatter.\nIf you want to parse frontmatter in toml like below, you want to set frontmatter delimiters to +++, and frontmatter language to toml.\n1+++ 2title = example 3+++ 4# Heading of the article 5... Default: ---\nFrontamtter template This one is optional but recommended if you want to parse frontmatter with correct types, or if you want to create new posts by CREATE NEW button of the Agit CMS file explorer.\nFrontmatter template specifies what type each property of frontmatter attributed to.\nThis information is used when Agit CMS parses markdown and generates a type-aware frontmatter editor, or when Agit CMS creates a new post with default frontmatter values.\nexample Let\u0026rsquo;s take a frontmatter below for example.\n1--- 2title: Configuration 3date: \u0026#39;2022-07-03T17:52:46+09:00\u0026#39; 4draft: false 5tags: [\u0026#34;React.js\u0026#34;, \u0026#34;Web Dev\u0026#34;] 6--- When Agit CMS parses frontmatter and generates a type-aware frontmatter editor, it tries to find a type for each property of frontmatter.\nIf you set date property of frontmatter to be a type of Date for instance, Agit CMS provides a date picker in the frontmatter editor.\nIf you set draft to be a type of Bool, Agit CMS provides a boolean toggler in the frontmatter editor.\nSupported types    type      Text plain text (ex. title: Configuration)   List of Text list of text (ex. tags: [\u0026quot;React.js\u0026quot;, \u0026quot;Web Dev\u0026quot;])   Multiline Text text with multiple lines   Date date in ISO 8601 format (ex. date: '2022-07-03T17:52:46+09:00')   Bool true or false (ex. draft: false)   Nest property that contains child properties    Media Folder Path Specify where you store media (image, GIF and so on) in your file system.\nMedia Public Path Specify the url path media content is accesible from.\nexample Suppose media folder path is /home/mysite/static/uploads, and /home/mysite/static/uploads/example.png\u0026rsquo;s url is https://mywebsite.com/contents/images/example.png.\nThen media public path should be /contents/images.\n","date":"Jul 3, 2022","img":"","permalink":"https://0xsuk.github.io/agitcms/configuration/","series":[],"tags":[],"title":"Configuration"},{"categories":[],"content":"Installation Install latest binary from here\n When downloading a binary, some warning will be displayed because Agit CMS is yet to be trusted by Windows/Mac. To suppress warning and continue, please reference below. Mac: Find agitcms in Finder. Click on the app pressing ctrl key. Select \u0026#34;Open\u0026#34;. (Open a Mac app from an unidentified developer - Apple Support) Windows: If \u0026#34;Windows protected your PC\u0026#34;, click on \u0026#34;More info\u0026#34;, and select \u0026#34;Run anyway\u0026#34;.  Adding a site  Agit CMS is a frontend interface for static site generators. You need a ready-to-run static site on your local computer.  Open Agit CMS and click NEW button.\nType your siteâ€™s name, and root folder path of the static site. These two configurations cannot be changed afterwards unless you modify ~/.agitcms/config.json directly.\nOnce you add a new site, click on it, then Agit CMS provides a file explorer where you can navigate through folders and files thas have .md extension.\nClick PIN button at the very top to pin a folder or a file to left sidebar for easy access.\nIntegrated Terminal Press Control + @ to open up a integrated terminal.\nTry starting a server of your static sites generator.\nIn hugo: hugo server\nIn jekyll: jekyll server\nNow your preview server is running on your host!\nModifying a post Click on a markdown file you want to edit in file explorer.\nAgit CMS provides a markdown editor with nice syntax highlighting and keymaps.\nType some text, right pane automatically renders markdown in a Github flavored style,\nFrontmatter Editor Click on a Frontmatter tab in the editor. Agit CMS automatically scans frontmatter section of your existing post, and provides a type-aware frontmatter editor like this.\nwhich is equal to\n1--- 2title: Quick Start 3type: docs 4date: \u0026#39;2022-07-03T16:11:40+09:00\u0026#39; 5draft: false 6comment: true 7toc: true 8reward: false 9pinned: false 10featured: false 11math: false 12categories: [] 13tags: [] 14series: [] 15images: 16 - \u0026#39;![](/uploads/2022-07-03-16:38:13.png)\u0026#39; 17--- You can confirm that for example, since draft is a boolean value, Agit CMS provides a boolean toggler for draft.\nYou can learn more about how to configure frontmatter language, delimiters and its types in the next page.\n","date":"Jul 3, 2022","img":"https://0xsuk.github.io/uploads/2022-07-03-16:38:13.png","permalink":"https://0xsuk.github.io/agitcms/quick-start/","series":[],"tags":[],"title":"Quick Start"},{"categories":[],"content":"Agit CMS is a multi-platform desktop application built on top of Electron, which works as a frontend interface for any static site generator, like Hugo and Jekyll.\nYou need to have a ready-to-run static sites on your local computer, as Agit CMS works as a frontend interface for it.\nFeatures  Vertical split style markdown editor. type-aware frontmatter interface.  Agit CMS provides a frontmatter interface which respects the type of each frontmatter property.\nAbove corresponds to the yaml below.\n1---2title:The Best CMS for Markdown Blogs3date:2022-06-29T11:06:12.000Z4draft:false5comment:true6toc:true7reward:false8pinned:false9featured:false10math:false11categories:12- Web Dev13tags:[]14series:15- Agit CMS16images:17- \u0026#39;/uploads/2022-06-29-19:53:03.png\u0026#39;18--- Integrated Terminal  Open an integrated terminal by pressing Ctrl+@.\nOther features\n mathjax rendering: $ a + b = c$ image pasting into editor pin folder in the sidebar custom frontmatter language(yaml/toml) \u0026amp; delimiters  Upcoming features\n custom css custom editor snippet custom editor toolbar custom editor syntax custom editor keymap custom markdown rendering media interface  Agit CMS tries to be a customizable headless CMS.\nDocs for older versions navigate to https://0xsuk.github.io/agitcms-v${VERSION} where ${VERSION} is a version of Agit CMS.\nExample: https://0xsuk.github.io/agitcms-v0.0.2-alpha\n","date":"Jun 30, 2022","img":"https://0xsuk.github.io/uploads/agitv1.0.0.png","permalink":"https://0xsuk.github.io/agitcms/overview/","series":[],"tags":[],"title":"Overview"},{"categories":["Web Dev"],"content":"Here\u0026rsquo;s a documentation of how to use Agit CMS.\nThe project link: https://github.com/0xsuk/agitcms\nOnly thing you need is a static site, powered by whatever \u0026ldquo;markdown based\u0026rdquo; static site generators like Hugo, Jekyll, Next.js, Gatsby.js and so on.\n\u0026ldquo;markdown based\u0026rdquo; means you write contents in markdown in your local PC.\nAgit CMS is NOT a git based CMS, or API based CMS. It\u0026rsquo;s a desktop app for writing markdown posts. So you need ready-to-run static sites on your local PC.\nIn this document I am going to use my blog ( 0xsuk.github.io) powered by Hugo as a static site example.\nAdd a new site First, add a site that you created using a certain static site generator.\nNavigate to home, and click \u0026ldquo;New\u0026rdquo; button.\nType site name, and site folder\u0026rsquo;s path.\nThese cannot be changed afterward unless you modify configuration file directly. Configuration file is explained later.\nFrontmatter Setting If you are using markdown based static site generator, you write post meta data in frontmatter right?\nIn my case, I have the following text at the beginning of my blog post\u0026rsquo;s markdown file as post\u0026rsquo;s meta data. (This meta data is called frontmatter)\n1--- 2title: Creating a Blog with Hugo 3date: 2022-02-11T04:22:29.699Z 4draft: false 5comment: false 6toc: true 7reward: false 8pinned: false 9featured: false 10math: true 11categories: null 12tags: null 13series: null 14images: 15 - /uploads/2022-02-11-02-43-09.png 16--- Each property of frontmatter has specific \u0026ldquo;type\u0026rdquo;.For example in this case, value of property title should be plain string, and value of property date should be ISO date format, and value of draft must be boolean.\nBy designating each property\u0026rsquo;s name and its type, Agit CMS automatically reads the frontmatter, and generate type-aware frontmatter editor.\nAlso when you create a new post by clicking Create New -\u0026gt; File, Agit CMS automatically writes frontmatter to the post.\nOf course you can create a new post if your static site generator has command for it. In Hugo, it\u0026rsquo;s hugo new content/posts/newPost.md right? Open integrated terminal to do so! Ah, so simple!\nTo do so, go to Setting, and scroll down to Frontmatter template section. There you add each frontmatter property\u0026rsquo;s name and type, and default value.\nMy configuration looks like this.\nAgit CMS at v1.0.0 only support 4 frontmatter property type.\n   type name description     String plain single line text   Date ISO date   Array of String list of plain text   Bool true or false    And I\u0026rsquo;m considering to add more type!\ncustom frontmatter parsing You can write frontmatter in yaml or toml format.\nNavigate to Setting, and set frontmatter language (yaml/toml), and frontmatter delimiters (\u0026quot;\u0026mdash;\u0026quot; is default).\nMedia Setting Go to Media section of Setting.\nThere you specify media folder\u0026rsquo;s path, and public path.\nMedia Folder Path is where you store image, gif, or movie. Media Public Path is an url path media is served from.\nFor example, let\u0026rsquo;s say you store media in ${root}/static/uploads. (where ${root} is your static site\u0026rsquo;s root folder path).\nAlso let\u0026rsquo;s say ${root}/static/uploads/image1.png is served from https://${your_web_site}.com/my_public_path/image1.png.\nIn this case, public path is /my_public_path, because media content is accessible from /my_public_path.\nOnce you configured media setting, you will be able to copy media content\u0026rsquo;s url path to clipboard easily, so that you can paste url path into markdown/wysiwyg editor.\nClick on Media button at the sidebar, and select whatever image you want to paste a url path of into markdown/wysiwyg editor. The image file\u0026rsquo;s name is now copied to your clipboard, being prefixed by public path.\nIntegrated Terminal This feature is the reason why Agit CMS is desktop application.\nMany CMS do tasks including starting preview server, creating a new post, managing media, in really complicated way. However, you can simply them by just running CMS in your local PC.\nToggle integrated terminal by Ctrl + @.\n Integrated terminal is still under development may be buggy under some environment.\n ","date":"Jun 3, 2022","img":"https://user-images.githubusercontent.com/97814789/171836599-b3d0a87e-186b-4bb6-afa6-049fc9c5bd3b.png","permalink":"https://0xsuk.github.io/agitcms-v0.0.2-alpha/how-to-use-agitcms/","series":null,"tags":["React.js"],"title":"How to Use Agit CMS"},{"categories":["Web Dev"],"content":"Hi suk here. This post explains how to create markdown editor/previewer with React.js / Codemirror 6. I\u0026rsquo;m writing this down because I had to learn how to build markdown editor for my project (a desktop based headless CMS for markdown blogs). Hope this post helps someone like me.\nGoal of this project We are going to create a simple markdown editor that works in your browser. If I write strings in markdown format in codemirror editor, React.js reads it, parses it, and displays preview.\nGithub Link: https://github.com/0xsuk/byome\nDemo: https://0xsuk.github.io/byome\nI recommend following this tutorial referencing the github code. If you are fast learner, just go to github repo and try understand the code. Most of it should make sense, except for scroll sync part, which I\u0026rsquo;ll explain later.\nSetup We are going to use Create React App. I created a starter for this tutorial, which is just a create-react-app with some useless files deleted and some npm packages installed.\npackages I\u0026rsquo;ve included:\n @codemirror/state @codemirror/view @codemirror/language @codemirror/lang-markdown @lezer/highlight unified remark-parses remark-rehype rehype-react remark-gfm  Seems a lot, but these packages are just an editor (codemirror) and a parser(unified, remark-*). I\u0026rsquo;ll explain each package of the list later.\nYou can clone my \u0026ldquo;setup\u0026rdquo; branch of Github repo to clone a starter for this project.\n1git clone -b setup git@github.com/0xsuk/byome.git 2cd byome 3npm i 4npm start It says Hello byome\nWriting Code Managing state We are going to use useState to manage contents of markdown, namely doc.\n1function App() { 2 const [doc, setDoc] = useState(\u0026#34;# Hello byome\u0026#34;); 3 4 return \u0026lt;div\u0026gt;{doc}\u0026lt;/div\u0026gt;; 5} Creating previewer If doc changes, we want to read it, parse it and display preview of it.\nWe\u0026rsquo;re going to use npm package called unified.\nunified is an interface for parsing, inspecting, transforming, and serializing content through syntax trees.\nWe parse doc using unified with some extensions, such as remark-parse, remark-rehype, remark-gfm, rehype-react.\nAs stated in https://github.com/unifiedjs/unified#description, unified consists of three parts: parser, transformer, and compiler.\nIn our case, we want to parse doc to markdown syntax tree first. So we use remark-parse as a parser. We parse doc to syntax tree, so that transformers such as remark-gfm can figure out what to do.\nSecond, we want additional functionality to our parser. There\u0026rsquo;s a remark plugin called remark-gfm for supporting GFM (autolink literals, footnotes, strikethrough, tables, tasklists), so we use this extension.\nThird, we want to compile the syntax tree to React component. There\u0026rsquo;s a package called rehype-react, which reads rehype (HTML) syntax tree and compiles it into react component. However, rehype-react is only compatible with rehype syntax. So we transform remark (Markdown) syntax to rehype (HTML) syntax using transformer called remark-rehype, and we compile rehype syntax to React component.\nAll of the process stated above can be written in simple code.\n1const md = unified() 2 .use(remarkParse) 3 .use(remarkGfm) 4 .use(remarkRehype) 5 .use(rehypeReact, { createElement, Fragment }) 6 .processSync(doc).result; At this point, App.jsx looks like this\n1import { useState, createElement, Fragment } from \u0026#34;react\u0026#34;; 2import \u0026#34;./App.css\u0026#34;; 3import { unified } from \u0026#34;unified\u0026#34;; 4import remarkParse from \u0026#34;remark-parse/lib\u0026#34;; 5import remarkGfm from \u0026#34;remark-gfm\u0026#34;; 6import remarkRehype from \u0026#34;remark-rehype\u0026#34;; 7import rehypeReact from \u0026#34;rehype-react/lib\u0026#34;; 8 9function App() { 10 const [doc, setDoc] = useState(\u0026#34;# Hello byome\u0026#34;); 11 12 const md = unified() 13 .use(remarkParse) 14 .use(remarkGfm) 15 .use(remarkRehype) 16 .use(rehypeReact, { createElement, Fragment }) 17 .processSync(doc).result; 18 19 return ( 20 \u0026lt;div\u0026gt; 21 \u0026lt;div\u0026gt;{doc}\u0026lt;/div\u0026gt; 22 \u0026lt;div\u0026gt;{md}\u0026lt;/div\u0026gt; 23 \u0026lt;/div\u0026gt; 24 ); 25} 26 27export default App; Whenever doc is updated, component is rerendered, generating new preview using unified.\nAnd if we npm start, localhost:3000 shows\nSeems it\u0026rsquo;s working!\n\u0026ldquo;# Hello byome\u0026rdquo; is successfully parsed into \u0026lt;h1\u0026gt;Hello byome\u0026lt;/h1\u0026gt;\nCreating editor We are goingt create a markdown editor using Codemirror 6.\nTwo major components of codemirror 6 is EditorState class and EditorView class. EditorState represents a state of editor, and EditorView wraps operation on state. The concept of state and view is explained in official document so take a look.\nWe create initial EditorState containing initial doc (\u0026ldquo;Hello byome\u0026rdquo;), as documented here https://codemirror.net/6/docs/ref/#state.EditorState^create.\n1const startState = EditorState.create({ 2 doc, 3 extensions: [ 4 EditorView.updateListener.of((update) =\u0026gt; { 5 if (update.docChanged) { 6 setDoc(update.state.doc.toString()); 7 } 8 }), 9 ], 10}); And we create new editor using EditorView class, as documented here https://codemirror.net/6/docs/ref/#view.EditorView.constructor\n1new EditorView({ 2 state: startState, 3 parent: ref.current, 4}); Where ref is a reference for editor DOM element.\nWe want to create new Editor only when ref gets attached, so we put them into useEffect\n1useEffect(() =\u0026gt; { 2 if (!ref.current) return; 3 const startState = EditorState.create({ 4 doc, 5 extensions: [ 6 EditorView.updateListener.of((update) =\u0026gt; { 7 if (update.changes) { 8 setDoc(update.state.doc.toString()); 9 } 10 }), 11 ], 12 }); 13 14 new EditorView({ 15 state: startState, 16 parent: document.getElementById(\u0026#34;editor\u0026#34;), 17 }); 18}, [ref]); I put them into useCodemirror.jsx so that App.jsx remains clean.\nNow App.jsx looks like this\n1import { useState, createElement, Fragment } from \u0026#34;react\u0026#34;; 2import \u0026#34;./App.css\u0026#34;; 3import { unified } from \u0026#34;unified\u0026#34;; 4import remarkParse from \u0026#34;remark-parse/lib\u0026#34;; 5import remarkGfm from \u0026#34;remark-gfm\u0026#34;; 6import remarkRehype from \u0026#34;remark-rehype\u0026#34;; 7import rehypeReact from \u0026#34;rehype-react/lib\u0026#34;; 8import useCodemirror from \u0026#34;./useCodemirror\u0026#34;; 9 10function App() { 11 const [doc, setDoc] = useState(\u0026#34;# Hello byome\u0026#34;); 12 const [editorRef, editorView] = useCodemirror({ initialDoc: doc, setDoc }); 13 14 const md = unified() 15 .use(remarkParse) 16 .use(remarkGfm) 17 .use(remarkRehype) 18 .use(rehypeReact, { createElement, Fragment }) 19 .processSync(doc).result; 20 21 return ( 22 \u0026lt;div\u0026gt; 23 \u0026lt;div ref={editorRef}\u0026gt;\u0026lt;/div\u0026gt; 24 \u0026lt;div\u0026gt;{md}\u0026lt;/div\u0026gt; 25 \u0026lt;/div\u0026gt; 26 ); 27} 28 29export default App; And useCodemirror.jsx\n1import { useRef, useState, useEffect } from \u0026#34;react\u0026#34;; 2import { EditorState } from \u0026#34;@codemirror/state\u0026#34;; 3import { EditorView } from \u0026#34;@codemirror/view\u0026#34;; 4 5function useCodemirror({ initialDoc, setDoc }) { 6 const ref = useRef(null); 7 const [view, setView] = useState(null); 8 9 useEffect(() =\u0026gt; { 10 if (!ref.current) return; 11 const startState = EditorState.create({ 12 doc: initialDoc, 13 contentHeight: \u0026#34;100%\u0026#34;, 14 extensions: [ 15 EditorView.updateListener.of((update) =\u0026gt; { 16 if (update.docChanged) { 17 setDoc(update.state.doc.toString()); 18 } 19 }), 20 ], 21 }); 22 23 const view = new EditorView({ 24 state: startState, 25 parent: ref.current, 26 }); 27 28 setView(view); 29 }, [ref]); 30 31 return [ref, view]; 32} 33 34export default useCodemirror; And it works!\nExtending Editor Functionality From here we\u0026rsquo;re going to dive a little bit deeper into extending editor functionality.\nadding lineNumber, Gutter, highlighting of active line \u0026 its gutter, markdown support, highlighting of headings, lineWrapping 1import { useRef, useState, useEffect } from \u0026#34;react\u0026#34;; 2import { EditorState } from \u0026#34;@codemirror/state\u0026#34;; 3import { 4 EditorView, 5 lineNumbers, 6 highlightActiveLine, 7 highlightActiveLineGutter, 8} from \u0026#34;@codemirror/view\u0026#34;; 9import { markdown, markdownLanguage } from \u0026#34;@codemirror/lang-markdown\u0026#34;; 10import { syntaxHighlighting, HighlightStyle } from \u0026#34;@codemirror/language\u0026#34;; 11import { tags } from \u0026#34;@lezer/highlight\u0026#34;; 12 13const markdownHighlighting = HighlightStyle.define([ 14 { tag: tags.heading1, fontSize: \u0026#34;1.6em\u0026#34;, fontWeight: \u0026#34;bold\u0026#34; }, 15 { 16 tag: tags.heading2, 17 fontSize: \u0026#34;1.4em\u0026#34;, 18 fontWeight: \u0026#34;bold\u0026#34;, 19 }, 20 { 21 tag: tags.heading3, 22 fontSize: \u0026#34;1.2em\u0026#34;, 23 fontWeight: \u0026#34;bold\u0026#34;, 24 }, 25]); 26 27function useCodemirror({ initialDoc, setDoc }) { 28 const ref = useRef(null); 29 const [view, setView] = useState(null); 30 31 useEffect(() =\u0026gt; { 32 if (!ref.current) return; 33 const startState = EditorState.create({ 34 doc: initialDoc, 35 contentHeight: \u0026#34;100%\u0026#34;, 36 extensions: [ 37 lineNumbers(), 38 highlightActiveLine(), 39 highlightActiveLineGutter(), 40 markdown({ 41 base: markdownLanguage, //Support GFM 42 }), 43 syntaxHighlighting(markdownHighlighting), 44 EditorView.lineWrapping, 45 EditorView.updateListener.of((update) =\u0026gt; { 46 if (update.docChanged) { 47 setDoc(update.state.doc.toString()); 48 } 49 }), 50 ], 51 }); 52 53 const view = new EditorView({ 54 state: startState, 55 parent: ref.current, 56 }); 57 58 setView(view); 59 }, [ref]); 60 61 return [ref, view]; 62} 63 64export default useCodemirror; scroll sync This is probably the most complicated part.\nBefore implementing scroll sync, take a glance at our App.css file because scrollSync is a matter of styling.\nApp.css\n1* { 2 box-sizing: border-box; 3 margin: 0; 4} 5 6 7#root { 8 height: 100vh; 9 overflow: hidden; 10} 11 12#editor-wrapper { 13 height: 100%; 14 display: flex; 15} 16 17 18#markdown { 19 height: 100%; 20 flex: 0 0 50%; 21 padding: 0 12px 0 0; 22 overflow-y: auto; 23} 24#preview { 25 font-size: 14px; /*make it same as codemirror */ 26 height: 100%; 27 flex: 0 0 50%; 28 padding: 0 0 0 12px; 29 border-left: solid 1px #ddd; 30 overflow-x: hidden; 31 overflow-y: auto; 32} 33 34#preview * { 35 overflow-x: auto; 36} And here\u0026rsquo;s App.jsx\n1import { useState, createElement, Fragment, useRef } from \u0026#34;react\u0026#34;; 2import \u0026#34;./App.css\u0026#34;; 3import { unified } from \u0026#34;unified\u0026#34;; 4import remarkParse from \u0026#34;remark-parse/lib\u0026#34;; 5import remarkGfm from \u0026#34;remark-gfm\u0026#34;; 6import remarkRehype from \u0026#34;remark-rehype\u0026#34;; 7import rehypeReact from \u0026#34;rehype-react/lib\u0026#34;; 8import useCodemirror from \u0026#34;./useCodemirror\u0026#34;; 9import \u0026#34;github-markdown-css/github-markdown-light.css\u0026#34;; 10 11let treeData; 12 13function App() { 14 const [doc, setDoc] = useState(\u0026#34;# Hello byome\u0026#34;); 15 const [editorRef, editorView] = useCodemirror({ initialDoc: doc, setDoc }); 16 const mouseIsOn = useRef(null); 17 18 const defaultPlugin = () =\u0026gt; (tree) =\u0026gt; { 19 treeData = tree; //treeData length corresponds to previewer\u0026#39;s childNodes length 20 return tree; 21 }; 22 23 const markdownElem = document.getElementById(\u0026#34;markdown\u0026#34;); 24 const previewElem = document.getElementById(\u0026#34;preview\u0026#34;); 25 26 const computeElemsOffsetTop = () =\u0026gt; { 27 let markdownChildNodesOffsetTopList = []; 28 let previewChildNodesOffsetTopList = []; 29 30 treeData.children.forEach((child, index) =\u0026gt; { 31 if (child.type !== \u0026#34;element\u0026#34; || child.position === undefined) return; 32 33 const pos = child.position.start.offset; 34 const lineInfo = editorView.lineBlockAt(pos); 35 const offsetTop = lineInfo.top; 36 markdownChildNodesOffsetTopList.push(offsetTop); 37 previewChildNodesOffsetTopList.push( 38 previewElem.childNodes[index].offsetTop - 39 previewElem.getBoundingClientRect().top //offsetTop from the top of preview 40 ); 41 }); 42 43 return [markdownChildNodesOffsetTopList, previewChildNodesOffsetTopList]; 44 }; 45 const handleMdScroll = () =\u0026gt; { 46 console.log(mouseIsOn.current); 47 if (mouseIsOn.current !== \u0026#34;markdown\u0026#34;) { 48 return; 49 } 50 const [markdownChildNodesOffsetTopList, previewChildNodesOffsetTopList] = 51 computeElemsOffsetTop(); 52 let scrollElemIndex; 53 for (let i = 0; markdownChildNodesOffsetTopList.length \u0026gt; i; i++) { 54 if (markdownElem.scrollTop \u0026lt; markdownChildNodesOffsetTopList[i]) { 55 scrollElemIndex = i - 1; 56 break; 57 } 58 } 59 60 if ( 61 markdownElem.scrollTop \u0026gt;= 62 markdownElem.scrollHeight - markdownElem.clientHeight //true when scroll reached the bottom 63 ) { 64 previewElem.scrollTop = 65 previewElem.scrollHeight - previewElem.clientHeight; //scroll to the bottom 66 return; 67 } 68 69 if (scrollElemIndex \u0026gt;= 0) { 70 let ratio = 71 (markdownElem.scrollTop - 72 markdownChildNodesOffsetTopList[scrollElemIndex]) / 73 (markdownChildNodesOffsetTopList[scrollElemIndex + 1] - 74 markdownChildNodesOffsetTopList[scrollElemIndex]); 75 previewElem.scrollTop = 76 ratio * 77 (previewChildNodesOffsetTopList[scrollElemIndex + 1] - 78 previewChildNodesOffsetTopList[scrollElemIndex]) + 79 previewChildNodesOffsetTopList[scrollElemIndex]; 80 } 81 }; 82 83 const handlePreviewScroll = () =\u0026gt; { 84 if (mouseIsOn.current !== \u0026#34;preview\u0026#34;) { 85 return; 86 } 87 const [markdownChildNodesOffsetTopList, previewChildNodesOffsetTopList] = 88 computeElemsOffsetTop(); 89 let scrollElemIndex; 90 for (let i = 0; previewChildNodesOffsetTopList.length \u0026gt; i; i++) { 91 if (previewElem.scrollTop \u0026lt; previewChildNodesOffsetTopList[i]) { 92 scrollElemIndex = i - 1; 93 break; 94 } 95 } 96 97 if (scrollElemIndex \u0026gt;= 0) { 98 let ratio = 99 (previewElem.scrollTop - 100 previewChildNodesOffsetTopList[scrollElemIndex]) / 101 (previewChildNodesOffsetTopList[scrollElemIndex + 1] - 102 previewChildNodesOffsetTopList[scrollElemIndex]); 103 markdownElem.scrollTop = 104 ratio * 105 (markdownChildNodesOffsetTopList[scrollElemIndex + 1] - 106 markdownChildNodesOffsetTopList[scrollElemIndex]) + 107 markdownChildNodesOffsetTopList[scrollElemIndex]; 108 } 109 }; 110 111 const md = unified() 112 .use(remarkParse) 113 .use(remarkGfm) 114 .use(remarkRehype) 115 .use(defaultPlugin) 116 .use(rehypeReact, { createElement, Fragment }) 117 .processSync(doc).result; 118 119 return ( 120 \u0026lt;\u0026gt; 121 \u0026lt;div id=\u0026#34;editor-wrapper\u0026#34;\u0026gt; 122 \u0026lt;div 123 id=\u0026#34;markdown\u0026#34; 124 ref={editorRef} 125 onScroll={handleMdScroll} 126 onMouseEnter={() =\u0026gt; (mouseIsOn.current = \u0026#34;markdown\u0026#34;)} 127 \u0026gt;\u0026lt;/div\u0026gt; 128 \u0026lt;div 129 id=\u0026#34;preview\u0026#34; 130 className=\u0026#34;markdown-body\u0026#34; 131 onScroll={handlePreviewScroll} 132 onMouseEnter={() =\u0026gt; (mouseIsOn.current = \u0026#34;preview\u0026#34;)} 133 \u0026gt; 134 {md} 135 \u0026lt;/div\u0026gt; 136 \u0026lt;/div\u0026gt; 137 \u0026lt;/\u0026gt; 138 ); 139} 140 141export default App; If scroll on markdown div is invoked, handleMdScroll() is called.\ncomputeElemsOffsetTop() computes offsetTop relative to markdown div\u0026rsquo;s top for each element of parsed markdown (child of treeData, try console.logging treeData to better understand).\nIf any parsed markdown element\u0026rsquo;s offsetTop is greater than scrollTop of markdown div, meaning the whole element is visible at the highest position in the visible area of editor, set scrollElemIndex to previous parsed markdown element (the one that is partially hidden above the visible area of editor).\nThen set scrollTop of preview div to corresponding element\u0026rsquo;s offsetTop relative to preview div, with proper additional value.\nAnd vice versa for handling preview scroll.\nNow our markdown editor finally looks like this\npretty neat right?\n","date":"Mar 25, 2022","img":"https://0xsuk.github.io/uploads/2022-03-25-12-13-39.png","permalink":"https://0xsuk.github.io/posts/2022-03-25-build-your-own-markdown-editor-with-react.js-and-codemirror-6/","series":null,"tags":["React.js","build-your-own-x"],"title":"Build Your Own Markdown Editor With React.js and Codemirror 6"},{"categories":null,"content":"Hugo - Static Site Generator Hugo is a popular opensource static site generator that runs on your computer.\nWe are going to cover how to install hugo on your computer and run it to build a fast static website or a blog.\nWhat is a static site? A static site prebuilds HTML/CSS/JavaScript code that will work as webpages, and serve them when users visit a website. In contrast, traditional dynamic website renders a webpage every time users visit a website. That\u0026rsquo;s the big difference between static and dynamic website - Build once, or build every time - and that\u0026rsquo;s why static websites are fast.\nIf you are planning to build a website that is not going to be updated frequently, you want to make it static because it\u0026rsquo;s faster. On the other hand, if you are sure that your website is going to be updated frequently, you want to make it dynamic because building every time an update occurs is painful work.\nAs for a blog, a static site seems to be a preferred choice, and that\u0026rsquo;s what we\u0026rsquo;re going to make. (This blog 0xsuk.github.io is actually a static blog powered by Hugo!)\nIn this article, I assume you have basic knowledge of git and github.\nInstalling Assuming you have git installed, the only thing you need to install is Hugo. You don\u0026rsquo;t need to install Golang to make Hugo work.\nHugo Installation guide is documented here\nCreate a site 1mkdir example \u0026amp;\u0026amp; cd example 2hugo new site . This command will create a new site generator in the specified directory. Here\u0026rsquo;s the tree of directories and files.\n1archetypes/ - default.md 2config.toml 3content/ 4data/ 5layouts/ 6static/ 7themes/ I\u0026rsquo;ll explain what each folder or file is responsible for briefly.\n archtypes/ contains default frontmatter template default.md. config.toml is where you configure hugo. content/ is where you put contents (blog posts) data/ is where you put meta data. files under static/ are served from the root path of the webpage. (ex. static/img.png is accesible from https://yourwebsite.com/img.png) themes/ is where you put website theme (explained later) files under layouts/ override theme layout.  Install a theme Hugo has many premade website themes available for free and you can pick whatever you like from here, but for this time we\u0026rsquo;re going to use https://hugothemesfree.com/an-extreme-fast-responsive-and-feature-rich-hugo-theme/ which is a current theme for this blog. Note that installation varies from theme to theme, and we\u0026rsquo;re installing the mentioned theme in the way that the author of the theme suggests.\n1# in the \u0026#34;example\u0026#34; directory 2git init 3git submodule add https://github.com/razonyang/hugo-theme-bootstrap themes/hugo-theme-bootstrap 4cp -a themes/hugo-theme-bootstrap/exampleSite/* . If you start a local server\n1hugo server and navigate to http://localhost:1313, you\u0026rsquo;ll see a page like this Easy. If you navigate to content/ directory, you\u0026rsquo;ll see many blog posts there.\ncontent/thisisexample.md will be served from /thisisexample in the url, and content/dir1/index.md will be served from /dir1, if there is one.\nCustomize a theme You might be wondering how you modify or customize a theme layout. That is where layouts/ directory comes in. Hugo reads theme/ directory first and builds a backbone of the site, and then Hugo reads layouts/ directory to detect any modification. Finally, Hugo loads contents in the content/ directory to the backbone, and your website starts.\nSo how do you customize a theme? It\u0026rsquo;s so easy.\nTo modify theme/[theme-name]/layouts/partial/header.html for example, you have to put an alternative layout in layouts/partial/header.html and so forth for all other files.\nCostomizing more, for example, use of cookies or color palettes, heavily depends on which theme you use. Some features might be buggy so be careful! so we\u0026rsquo;re not going to dive deeper.\nFrontmatter Try opening one markdown file in the content/ directory. You\u0026rsquo;ll see something placed at the top. Here\u0026rsquo;s the top of content/about/index.md.\n1+++ 2title = \u0026#34;About\u0026#34; 3description = \u0026#34;Hugo, the world\u0026#39;s fastest framework for building websites\u0026#34; 4date = \u0026#34;2019-02-28\u0026#34; 5aliases = [\u0026#34;about-us\u0026#34;, \u0026#34;about-hugo\u0026#34;] 6author = \u0026#34;Hugo Authors\u0026#34; 7reward = false 8postDate = false 9readingTime = false 10+++ This wierd thing placed at the top of every blog post is called frontmatter.\nFrontmatter is what specifies file\u0026rsquo;s attributes. title, categories, and so on. The theme installed uses these information.\nCreate a new post If you want to create a new post newpost.md in the content directory, you can create empty file content/newpost.md. However, this method is not preferred because writing frontmatter every time you create a new post is painful work. Hugo has a command for it.\n1hugo new newpost.md Then Hugo reads archtypes/default.md and creates a new post content/newpost.md based on that file. archtypes/default.md is what is called frontmatter template, and you can modify it on your taste.\nHosting Popular options for hosting are Github Pages and Netlify. Both are good, but I prefer Netlify. In either case, you have to push your hugo website into your github repository. Go to github and create a new repository. Push your local website to github repository.\nThen, go to Netlify and sign up with github, import a site from the repository, and your website is up. Easy.\nManaging Writing blog posts on text editor is kind of hard. There\u0026rsquo;s a way to make it easy. Use a CMS - Content Management System that helps you make an update easier. There are many CMS that are suitable for static sites:\n Forestry.io Netlify CMS Frontmatter CMS Hokus CMS  to name a few.\nOK, that\u0026rsquo;s it for this article.\nBy the way I\u0026rsquo;m building a Headless CMS that is more suitable for static sites, so why not catch me on Twitter?\n","date":"Feb 11, 2022","img":"https://0xsuk.github.io/uploads/2022-02-11-02-43-09.png","permalink":"https://0xsuk.github.io/posts/2022-02-11-creating-a-blog-with-hugo/","series":null,"tags":null,"title":"Creating a Blog With Hugo"},{"categories":null,"content":"I\u0026rsquo;m a 17 years old self-taught programmer from Japan who loves technologies.\nLearning\n Web Development (React / Node.js / Golang) Machine Learning / Statistics Cyber Security / CTFs (HackTheBox/TryHackMe) Robotics  I\u0026rsquo;m building a desktop based headless CMS for markdown blogs.\nLinks:\n Twitter! HackTheBox TryHackMe  ","date":"Jan 1, 0001","img":"","permalink":"https://0xsuk.github.io/about/","series":null,"tags":null,"title":"About"},{"categories":null,"content":"","date":"Jan 1, 0001","img":"","permalink":"https://0xsuk.github.io/_contact/","series":null,"tags":null,"title":"Contact"},{"categories":null,"content":"","date":"Jan 1, 0001","img":"","permalink":"https://0xsuk.github.io/offline/","series":null,"tags":null,"title":"Offline"}]